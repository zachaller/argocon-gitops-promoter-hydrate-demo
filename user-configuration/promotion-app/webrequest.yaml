apiVersion: promoter.argoproj.io/v1alpha1
kind: WebRequestCommitStatus
metadata:
  name: change-management-approval
  namespace: default
  labels:
    test: test2
spec:
  descriptionTemplate: Check for approved change records in current time window
  expression: |
    Response.StatusCode == 200 &&
    len(Response.Body.change_records) > 0 &&
    any(Response.Body.change_records, {
      date(#.change_request.start_time) <= now() &&
      date(#.change_request.end_time) >= now()
    })
  httpRequest:
    headerTemplates:
      Accept: application/json
    method: GET
    timeout: 30s
    urlTemplate: http://localhost:8987/v1/change-management-service/changes/search?asset_id=1372489579564901493&commit_id={{.Environment.Proposed.Dry.Sha }}&limit=25
  key: change-management-approval
  mode:
    trigger:
      # Reconciliation interval
      requeueDuration: 1m
      
      triggerExpression: |
        // Current state
        let currentDrySha = Environment.Proposed.Dry.Sha;
        let lastCheckedDrySha = TriggerData.lastCheckedDrySha ?? "";
        let hasOpenPR = Environment.PullRequest != nil &&
                        string(Environment.PullRequest.State) == "open";

        // New dry SHA we haven't checked yet?
        let isNewDrySha = currentDrySha != lastCheckedDrySha;

        // Time-based triggering: configurable polling interval (30 minutes)
        let pollingIntervalMinutes = 30;
        let isFirstRun = TriggerData.lastRequestTime == nil;
        
        // Calculate if enough time has passed (only if not first run)
        let shouldTriggerByTime = !isFirstRun && (
          (now() - date(TriggerData.lastRequestTime)) >= duration(string(pollingIntervalMinutes) + "m")
        );

        // Trigger if:
        // 1. First run (no previous request time)
        // 2. New SHA (immediate check)
        // 3. OR enough time has passed since last request (continuous polling)
        let shouldTrigger = hasOpenPR && (isFirstRun || isNewDrySha || shouldTriggerByTime);

        {
          trigger: shouldTrigger,
          lastCheckedDrySha: currentDrySha,
          lastRequestTime: shouldTrigger ? now() : TriggerData.lastRequestTime
        }

      # Store only records that meet the approval criteria
      responseExpression: |
        let approvedRecords = filter(Response.Body.change_records ?? [], {
          date(#.change_request.start_time) <= now() && date(#.change_request.end_time) >= now()
        });

        {
          statusCode: Response.StatusCode,
          totalRecordCount: len(Response.Body.change_records ?? []),
          approvedRecords: approvedRecords,
          approvedCount: len(approvedRecords),
          lastCheckedAt: string(now())
        }

  promotionStrategyRef:
    name: argocon-demo
  reportOn: proposed

---
apiVersion: promoter.argoproj.io/v1alpha1
kind: WebRequestCommitStatus
metadata:
  name: change-management-open
  namespace: default
spec:
  descriptionTemplate: Open change request for dry SHA
  expression: |
    Response.StatusCode == 202 &&
    Response.Body != nil &&
    Response.Body.id != nil &&
    Response.Body.id != ""
  httpRequest:
    bodyTemplate: |
      {
        "asset_id": "1372489579564901493",
        "on_behalf_of": "zaller",
        "short_description": "Deploy commit {{ .Environment.Proposed.Dry.Sha }} to {{ .Environment.Branch }} via automated pipeline",
        "description": "Automated deployment of commit {{ .Environment.Proposed.Dry.Sha }} to {{ .Environment.Branch }} for asset 1372489579564901493. Standard deployment following approved change management procedures and best practices for proper change tracking.",
        "environment": "staging",
        "backout_plan": "Rollback to previous version by redeploying previous commit using automated rollback procedure and validation",
        "change_plan": "Standard change roll out using automated deployment pipeline and infrastructure as code with monitoring",
        "test_plan": "Pre-deployment testing completed in lower environments with automated test suite validation and verification",
        "category": "Application",
        "sub_category": "Release",
        "commit_id": "{{ .Environment.Proposed.Dry.Sha }}",
        "start_time": "{{ now | date "2006-01-02T15:04:05Z07:00" }}",
        "end_time": "{{ now | dateModify "+5m" | date "2006-01-02T15:04:05Z07:00" }}",
        "risk": "low",
        "repo_url": "https://github.intuit.com/your-org/your-repo"
      }
    headerTemplates:
      Accept: application/json
      Content-Type: application/json
    method: POST
    timeout: 30s
    urlTemplate: http://localhost:8987/v1/change-management-service/change
  key: change-management-open
  mode:
    trigger:
      triggerExpression: |
        // Current state
        let currentDrySha = Environment.Proposed.Dry.Sha;
        let lastRequestedDrySha = TriggerData.lastRequestedDrySha ?? "";
        let hasOpenPR = Environment.PullRequest != nil &&
                        string(Environment.PullRequest.State) == "open";

        // New dry SHA we haven't tried yet?
        let isNewDrySha = currentDrySha != lastRequestedDrySha;

        // Should we retry? Only for transient errors
        let lastStatusCode = ResponseData != nil ? ResponseData.statusCode : 0;
        let isRetryable = lastStatusCode == 429 || lastStatusCode >= 500;
        let needsRetry = currentDrySha == lastRequestedDrySha &&
                         Phase != "success" &&
                         isRetryable;

        // Trigger on new SHA OR retryable failure
        let shouldTrigger = hasOpenPR && (isNewDrySha || needsRetry);

        {
          trigger: shouldTrigger,
          lastRequestedDrySha: shouldTrigger ? currentDrySha : lastRequestedDrySha
        }
      requeueDuration: 30s

      # Store response data for debugging
      responseExpression: |
        {
          statusCode: Response.StatusCode,
          changeId: Response.Body.id ?? "",
          message: Response.Body.message ?? "",
          changeRequest: Response.Body.change_request ?? {},
          lastRequestedAt: string(now())
        }
  promotionStrategyRef:
    name: argocon-demo
  reportOn: proposed
